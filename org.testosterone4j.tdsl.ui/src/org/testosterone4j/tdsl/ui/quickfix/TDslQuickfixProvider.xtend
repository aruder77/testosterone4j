/*
 * #%L
 * org.testosterone4j.tdsl.ui
 * %%
 * Copyright (C) 2015 Axel Ruder
 * %%
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * #L%
 */
/*
* generated by Xtext
*/
package org.testosterone4j.tdsl.ui.quickfix

import org.testosterone4j.tdsl.jvmmodel.MetaModelExtensions
import org.testosterone4j.tdsl.tDsl.Field
import org.testosterone4j.tdsl.tDsl.Operation
import org.testosterone4j.tdsl.tDsl.OperationMapping
import org.testosterone4j.tdsl.tDsl.TDslFactory
import org.testosterone4j.tdsl.validation.TDslValidator
import java.util.HashMap
import javax.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.model.edit.IModificationContext
import org.eclipse.xtext.ui.editor.quickfix.Fix
import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
import org.eclipse.xtext.validation.Issue
import org.eclipse.xtext.xbase.ui.quickfix.XbaseQuickfixProvider

//import org.eclipse.xtext.ui.editor.quickfix.Fix
//import org.eclipse.xtext.ui.editor.quickfix.IssueResolutionAcceptor
//import org.eclipse.xtext.validation.Issue

/**
 * Custom quickfixes.
 *
 * see http://www.eclipse.org/Xtext/documentation.html#quickfixes
 */
class TDslQuickfixProvider extends XbaseQuickfixProvider {

	@Inject
	MetaModelExtensions metaModelExtensions;

	@Fix(TDslValidator::UNSUFFICIENT_OPERATION_MAPPINGS)
	def capitalizeName(Issue issue,
			IssueResolutionAcceptor acceptor) {
		acceptor.accept(
				issue,
				"Insert missing operation mappings",
				"Insert all necessary operation mappings using default datatypes.",
				"upcase.png") [EObject element,
							IModificationContext context |
						val field = element as Field
						val controlOperations = field.getControl()
								.getOperations();
						val opMappings = new HashMap<Operation, OperationMapping>();
						for (opMapping : field.getOperations()) {
							opMappings.put(opMapping.getName(), opMapping);
						}
						for (Operation op : controlOperations) {
							if (!opMappings.containsKey(op)) {
								val factory = TDslFactory::eINSTANCE;
								val mapping = factory.createOperationMapping();
								mapping.setName(op);
								mapping.setDataType(metaModelExtensions
									.defaultDataType(field, op.getReturnType()));
								val params = op.getParams();
								for (param : params) {
									val dtMapping = factory
										.createDataTypeMapping();
									dtMapping.setName(param);
									dtMapping.setDatatype(metaModelExtensions
										.defaultDataType(field, param.getType()));
									mapping.getDataTypeMappings().add(dtMapping);
								}
								field.getOperations().add(mapping);
							}
						}
					]
	}

	@Fix(TDslValidator::CONTROL_NOT_IN_TOOLKIT)
	def addControlToToolkit(Issue issue,
			IssueResolutionAcceptor acceptor) {
		val label = "Add control '" + issue.data.get(0) + "' to toolkit";
		acceptor.accept(issue, label, label, "") [EObject element, IModificationContext context |
				val field = element as Field;
				val act = metaModelExtensions.parentActivity(field);
				val toolkit = metaModelExtensions.getToolkit(act);
				if (toolkit != null) {
					toolkit.getControls().add(field.getControl());
				}
			]
	}
}
