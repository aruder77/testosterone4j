<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Beschreibung der UI-Struktur</title>

<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="ivp.html" title="">
</head>
<body>
<a name="uistruktur"></a>
<h1>Beschreibung der UI-Struktur</h1>
<p>
Die Struktur der Benutzeroberfläche muss einmalig, in der Regel parallel zur Entwicklung der Benutzeroberfläche,
modelliert werden und dient dann als Ausgangsbasis für die Spezifikation der Use-Cases und Tests.
</p>
<p>
Da die Spezifikation von Tests bei TDsl im Fokus steht, beschränkt sich die Beschreibung der UI ausschließlich
auf die Informationen die für die Spezifikation der Tests sowie die Automatisierung notwendig sind.
</p>
<p>
Im Wesentlichen müssen folgende Informationen festgehalten werden:
</p>
<p>
<ul>
	<li>
		In welche "Seiten" die Benutzeroberfläche gegliedert ist (in TDsl-Jargon <em>Activities</em>)
	</li>
	<li>
		Welche Benutzeroberflächen-Elemente (<em>Controls</em>) auf dieser Seite vorhanden sind
	</li>
	<li>
		Welche <em>Operationen</em> von den Controls angeboten werden
	</li>
	<li>
		Welche <em>Datentypen</em> von den Operationen verwendet werden (als Parameter und Rückgabewert)
	</li>
	<li>
		Welche übergreifenden Operationen von der Seite selbst angeboten werden
	</li>
</ul>
</p>
<a name="datentypen"></a>
<h2>Datentypen</h2>
<p>
Zunächst müssen die fachlichen Datentypen der Anwendung und deren Äquivalenzklassen modelliert werden.
Damit der Testfall-Generator für jede beliebige Eingabe entscheiden kann was für ein Wert als Eingabe-Datum
verwendet werden darf, müssen wir ihm in Form einer Datentyp-Deklaration diese bekannt machen. 
</p>
<p>
Dabei wird nach dem Äquivalenzklassen-Prinzip vorgegangen. Eine Äquivalenzklasse ist eine Klasse von
(Eingabe-)Werten, für die von der zu testenden Anwendung gleiches Verhalten vom Test-Designer erwartet wird.
Dies erfolgt unter der Annahme dass es sinnvoll ist zumindest einen Wert aus jeder Äquivalenzklasse zu
testen.
</p>
<p>
Ein Beispiel für die Deklaration eines TDsl-Datentyps sieht folgendermaßen aus:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">datatype</span>&nbsp;IntegerDT&nbsp;<span class="keyword">type</span>&nbsp;Integer&nbsp;{
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">class</span>&nbsp;largeNegative&nbsp;<span class="keyword">values</span>&nbsp;-2147483646..-1000
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">class</span>&nbsp;negative&nbsp;<span class="keyword">values</span>&nbsp;-1..999
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">class</span>&nbsp;zero&nbsp;<span class="keyword">value</span>&nbsp;0
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">class</span>&nbsp;positive&nbsp;<span class="keyword">values</span>&nbsp;1..999
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">class</span>&nbsp;largePositive&nbsp;<span class="keyword">values</span>&nbsp;1000..2147483647
<br/>
}
<br/>
</p>
</div>
</div>
</p>
<p>
Auch der technische Datentyp muss TDsl bekannt gemacht werden.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">type</span>&nbsp;Integer&nbsp;<span class="keyword">mappedBy</span>&nbsp;java.lang.Integer
<br/>
</p>
</div>
</div>
</p>
<p>
Da für die Generierung der Testfälle Java verwendet wird, muss durch die Angabe von <span class="inlinecode"><span class="keyword">mappedBy</span></span>
angegeben werden auf was für einen Java-Datentyp der Typ abgebildet wird.
</p>
<p>
Obiges Beispiel demonstriert die Verwendung von Äquivalenzklassen, im Allgemeinen sollten jedoch für
Datentypen wirklich die fachliche Datentypen der Anwendung verwendet werden, beispielsweise <em>Seriennummer</em>,
<em>Baujahr</em> oder <em>Postleitzahl</em>. 
</p>
<a name="controls"></a>
<h2>Controls</h2>
<p>
Als nächstes werden die Benutzerelemente der Anwendung modelliert. Dies muss nur einmalig pro verwendetem
UI-Toolkit durchgeführt werden, nicht für jede zu testende Anwendung. Dieser Schritt ist erforderlich,
da TDsl mit jedem beliebigen Testautomatisierungsframework und jedem beliebigen UI-Toolkit verwendet
werden kann.
</p>
<p>
Ein Beispiel für die modellierung eines Controls ist Foldendes:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">control</span>&nbsp;TextControl&nbsp;{
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;String&nbsp;getText
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;setText(String&nbsp;str)
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;Boolean&nbsp;isEnabled
<br/>
}
<br/>
</p>
</div>
</div>
</p>
<p>
<em>String</em> und <em>Boolean</em> sind dabei technische Datentypen die mit <span class="inlinecode">type</span> definiert worden sind. Im
Beispiel wird ein Control <em>TextControl</em> definiert, das drei Operationen bietet.
</p>
<p>
<ul>
	<li>
		die Operation <em>getText</em>, die den aktuellen String-Wert des Controls zurückliefert
	</li>
	<li>
		die Operation <em>setText</em>, die den Wert <em>str</em> im Control setzt
	</li>
	<li>
		die Operation <em>isEnabled</em>, die ermittelt ob das Control gerade aktiviert ist
	</li>
</ul>
</p>
<p>
So können und müssen sämtliche von der Anwendung verwendete UI-Controls mit ihren Operationen in TDsl
modelliert werden. Natürlich ist auch die verwendung von mehreren Parametern (durch Komma getrennt) pro
Operation möglich.
</p>
<p>
Ein Beispiel für ein komplexeres Control wie zum Beispiel einer Tabelle sieht wie folgt aus:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
</p>
</div>
</div>
</p>
<a name="activities"></a>
<h2>Activities</h2>
<p>
<em>Activities</em> beschreiben die "Seiten" der Benutzeroberfläche. Was genau eine Seite darstellt obliegt
dem Test-Designer. Eine Activity kann dabei eine komplette Seite einer Web-Anwendung darstellen oder
aber auch nur einen Teil davon. Wichtig ist, dass die Anwendung disjunkt in Activities zerlegt wird.
</p>
<a name="fields"></a>
<h3>Fields</h3>
<p>
Auf jeder Activity (Seite) befinden sich Instanzen von Controls (<em>Fields</em>), über die der Benutzer seine
Interaktion mit der Anwendung durchführt, beispielsweise das Eintragen eines Datums in ein Textfeld,
oder das Klicken auf einen Button.
</p>
<p>
Eine Activity wird wie folgt in TDsl spezifiziert:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">activity</span>&nbsp;LoginPage&nbsp;{
<br/>
&nbsp;&nbsp;
<br/>
&nbsp;&nbsp;<span class="keyword">field</span>&nbsp;userName&nbsp;<span class="keyword">identifiedBy</span>&nbsp;<span class="string">"key.userName"</span>&nbsp;<span class="keyword">control</span>&nbsp;TextControl&nbsp;{
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;UserNameDT&nbsp;getText
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;setText(UserNameDT&nbsp;str)
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;BooleanDT&nbsp;isEnabled
<br/>
&nbsp;&nbsp;}
<br/>
&nbsp;&nbsp;
<br/>
&nbsp;&nbsp;<span class="keyword">field</span>&nbsp;password&nbsp;<span class="keyword">identifiedBy</span>&nbsp;<span class="string">"key.password"</span>&nbsp;<span class="keyword">control</span>&nbsp;TextControl&nbsp;{
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;PasswordDT&nbsp;getText
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;setText(PasswordDT&nbsp;str)
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;BooleanDT&nbsp;isEnabled
<br/>
&nbsp;&nbsp;}
<br/>
&nbsp;&nbsp;
<br/>
&nbsp;&nbsp;<span class="keyword">field</span>&nbsp;loginButton&nbsp;<span class="keyword">identifiedBy</span>&nbsp;<span class="string">"key.login"</span>&nbsp;<span class="keyword">control</span>&nbsp;ButtonControl&nbsp;{
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;click&nbsp;=&gt;&nbsp;OverviewPage
<br/>
&nbsp;&nbsp;}
<br/>
&nbsp;&nbsp;
<br/>
&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;login(UserNameDT&nbsp;userName,&nbsp;PasswordDT&nbsp;password)&nbsp;{
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#userName.setText(str&nbsp;=&nbsp;userName)
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#password.setText(str&nbsp;=&nbsp;password)
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#loginButton.click
<br/>
&nbsp;&nbsp;}&nbsp;=&gt;&nbsp;OverviewPage
<br/>
}
<br/>
</p>
</div>
</div>
</p>
<p>
Die Activity <em>LoginPage</em> besitzt drei Eingabeelemente (Fields): zwei Textfelder für Benutzername und
Passwort und einen Login-Button. Die drei Elemente werden jeweils durch eine <em>Field</em>-Definition beschrieben.
</p>
<p>
Das erste Field wird durch <em>userName</em> innerhalb der Seite eindeutig identifiziert. Der String nach dem
Schlüsselwort identifiedBy <em>"key.userName"</em> gibt eine ID an, mit Hilfe dessen das Test-Automatisierungsframework
das Control auf der Seite finden und identifizieren kann. In der Regel ist es dafür nötig diese ID bei
der Implementierung der Anwendung im Control zu hinterlegen.
</p>
<p>
Das <em>control</em>-keyword gibt an um welches Control es sich bei diesem Eingabeelement handelt. 
</p>
<p>
Im darauf folgendem Block müssen nun sämtliche Operationen des Controls spezifisch für dieses Feld wiederholt
deklariert werden. Das ist aus zwei Gründen wichtig:
</p>
<p>
<ol>
	<li>
		Für sämtliche (technische) Datentypen von Operations-Parametern und Rückgabewerte müssen für dieses
			spezifische Feld der passende fachliche Datentyp angegeben werden. Der fachliche Datentyp kann für
			jedes Feld ein anderer sein, deshalb muss dieses Mapping für jedes Feld angegeben werden. Im obigen
			Beispiel ist der Datentyp für get-/setText des Feldes "userName" UserNameDT, während der Datentyp
			für das Feld "password" PasswordDT beträgt.
	</li>
	<li>
		Der Aufruf einer Operation eines bestimmten Benutzeroberflächen-Elements kann einen Übergang zu
			einer anderen Seite auslösen. Dies kann in TDsl durch die Verwendung des Operators <em>=&gt;</em> modelliert
			werden, dem die nachfolgende Activity angegeben wird. Im obigen Beispiel führt ein Klick auf den 
			loginButton zur Activity <em>OverviewPage</em>.
	</li>
</ol>
</p>
<a name="activityOperations"></a>
<h3>Activity-Operationen</h3>
<p>
Oft ist es sinnvoll mehrere Einzeloperationen auf UI-Elementen (Fields) zu einer fachlichen Operation
der Activity zusammenzufassen. Ein Beispiel hierfür zeigt folgendes Listing.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">activity</span>&nbsp;LoginPage&nbsp;{
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">field</span>&nbsp;loginName&nbsp;...
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">field</span>&nbsp;password&nbsp;...
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">field</span>&nbsp;loginButton&nbsp;...
<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">op</span>&nbsp;login(UserNameDT&nbsp;userName,&nbsp;PasswordDT&nbsp;password)&nbsp;{
<br/>
#userName.setText(str&nbsp;=&nbsp;userName)
<br/>
#password.setText(str&nbsp;=&nbsp;password)
<br/>
#loginButton.click
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;=&gt;&nbsp;OverviewPage
<br/>
}
<br/>
</p>
</div>
</div>
</p>
<p>
Es wird eine Operation <em>login</em> deklariert, die Benutzername und Passwort entgegennimmt und den Anmeldevorgang
vornimmt. Dabei verwendet die Operation die Control-Operationen um den Vorgang durchzuführen. Die Syntax
und die Möglichkeiten des Operations-Inhalts entspricht denen von Use-Case Blöcken, die im folgenden
Kapitel näher vorgestellt wird. Als Resultat der Operation wird zur <em>OperviewPage</em> verzweigt. Wichtig
dabei ist, dass der letzte Aufruf der Operation zur gleichen Activity verzweigt wie die Operation selbst. 
</p>
</body>
</html>
